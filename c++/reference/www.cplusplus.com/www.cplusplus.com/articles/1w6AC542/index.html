<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>How to Make a Game - C++ Articles</title>
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" type="text/css" href="/v321/main.css">
<script src="/v321/main.js" type="text/javascript"></script>
<script type='text/javascript'>
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
(function() {
var gads = document.createElement('script');
gads.async = true;
gads.type = 'text/javascript';
var useSSL = 'https:' == document.location.protocol;
gads.src = (useSSL ? 'https:' : 'http:') + 
'//www.googletagservices.com/tag/js/gpt.js';
var node = document.getElementsByTagName('script')[0];
node.parentNode.insertBefore(gads, node);
})();
</script>

<script type='text/javascript'>
googletag.cmd.push(function() {
googletag.defineSlot('/32882001/L', [728, 90], 'div-gpt-ad-1427191279638-0').addService(googletag.pubads());
googletag.enableServices();
});
</script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="/articles/">Articles</a></li>
<li class="here">How to Make a Game</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div id="I_content">
<div class="C_art">
<div id="I_author">Published by <b><a href="/user/ModShop/" rel="author">ModShop</a></b></div>
<div id="I_date">May 16, 2011 (last update: Dec 24, 2014)</div>
<h1>How to Make a Game</h1>
<div id="I_score">Score: 4.2/5 (991 votes)</div>
<div id="I_stars"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star-empty.png" width="16" height="16" alt="*"></div>
<div id="I_content">
It has been recently brought to my attention that many people ask about game development, yet there aren't many articles on the topic. I've decided to shed some light on the general process of developing a game from start to finish. Keep in mind that that this is primarily an overview and: A. Won't apply verbatim to all projects. B. Is not a complete, step by step guide to a finished result. You will still need to figure out quite a bit of stuff on your own to have a game.<br>
<br>
<hr>
<br>
<u><b>Step 1: Choose Your Game Library</b></u>
<br>
Unless you want to write your own library for all the nitty gritty graphics/sound programming, you will probably want to get a game library. There are many game libraries out there, but they all offer the same base functionality<br>
<br>
<u><i>Features that you want your library to have:</i></u>
<ul>
    <li>A way to load and render images<br>
    <li>A way to load and play audio<br>
    <li>Basic image manipulation (rotation, etc)<br>
    <li>Primitive drawing capabilities(circles, lines, rectangles, dots, etc)<br>
    <li>Ability to render text<br>
    <li>Ability to track time and wait <br>
    <li>Ability to create and control threads (is nice, but not required)<br>
</ul>
<br>
<i><u>Some game libraries include:</u></i>
<ul>
    <li>Simple Fast Multi-Media Library (SFML): <a href="http://www.sfml-dev.org/">http://www.sfml-dev.org/</a></li>
    <li>Simple DirectMedia Layer (SDL): <a href="http://www.libsdl.org/">http://www.libsdl.org/</a></li>
    <li>Allegro: <a href="http://www.allegro.cc/">http://www.allegro.cc/</a></li>
    <li>OpenGL (Rendering only, however, there are wrapper libraries like AllegroGL): <a href="http://www.opengl.org/">http://www.opengl.org/</a></li>
    <li>DirectX (Windows only): <a href="http://msdn.microsoft.com/en-us/directx/">http://msdn.microsoft.com/en-us/directx/</a></li>
    <li>Irrlicht (3d library): <a href="http://irrlicht.sourceforge.net/">http://irrlicht.sourceforge.net/</a></li>
</ul>
<br>
<br>
<hr>
<br>
<br>
<u><b>Step 2: Define the Concept</b></u>
<br>
All games start here, merely ideas in someone's head.<br>
First, come up with an idea for a game. Once you have a simple idea, expand on it. For example, if it is a board game, what is the objective/How do you win? What will the rules be like? etc. If your game will have characters or a story, create them. Make sure you have a pretty well-defined concept of what your game will be when it's finished. The more complex the game, the better you should plan it out in the beginning so you don't have to worry about the game itself while your coding. Keep in mind that your game WILL evolve as you create it.<br>
<br>
<br>
<hr>
<br>
<br>
<u><b>Step 3: Plan Your Engine</b></u>
<br>
If you're making a board game or basic arcade equivalent you can skip this entirely and simply program your game. For more complex games, however, you may want to look into using a pre-made engine, or writing your own "engine". What even is a game engine you ask? While they vary widely in structure and overall functionality, you can think of a game engine as a super-powered library that provides higher level functionality such as physics, resource handling and game entity management. Whether you choose to use an existng engine or create your own, so to speak, is up to you and depends on how much programming you actually want to do. Using a pre-made engine will simplify your job as a programmer to scripting gameplay/events more than anything else.<br>
<br>
Why did I say plan rather than choose? Well, odds are you're not making the next Elder Scrolls, and therefor, can create your own "engine" of sorts. Keep in mind that you will not be creating the next Unreal Engine, and most of the code you write and intend to be reusable (as is the point of an engine) will end up being so intertwined with your game logic that it is impossible to reuse easily. With this in mind, don't worry if parts of your "engine" rely on code specific to the game, this is just going to happen. Instead of focusing on making a completely reusable, super robust framework, focus on making sure the code is readable, organized and functional. Focus first on making the game, then try to create portable modules. If you absolutely must write something useful and reusable, resource managers and other various utility classes are good starting points. <br>
<br>
<br>
<hr>
<br>
<br>
<u><b>Step 4: Write Your Engine</b></u> (if you're making your own)<br>
<br>
Now its time to actually start writing your engine, provided this is the route you chose. This doesn't necessarily mean the game itself, but rather, core rendering, physics, and file handling; essentially the functions and classes that will be used to construct your game. Simple games won't really require much of a framework, and can just be programmed using your game library directly. One of the most important, and most neglected, components of larger games is the resource manager. The resource manager is (presumably) a class that is responsible for loading resources (think graphics and sound), ensuring that resources are loaded only once, and unloading resources when they are no longer needed. RAM isn't infinite, so if your game is loading a separate copy of the same image for every piece of grass in the universe, you're going to have a bad time. See an excellent resource manager below by <b>Xander314</b>.<br>
<br>
<br>
Resource Manager by <b>Xander314</b>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br></code></pre></td>
<td class="source"><pre><code><cite>/*
 ResourceManagerB.hpp - Generic template resource manager				
									
 (C) Alexander Thorne (SFML Coder) 2011	
 &lt;a href="http://sfmlcoder.wordpress.com/"&gt;http://sfmlcoder.wordpress.com/&lt;/a&gt;	
		
 Manages loading and unloading of a resource type specified by a
 template argument.

****************************************************************/</cite>

<dfn>#include &lt;map&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>

<var>typedef</var> <var>const</var> std::string URI;

<cite>// exceptions</cite>
<var>namespace</var> Exceptions {

	<cite>// thrown if user requests a resource URI not present in the manager's list</cite>
	<var>class</var> URINotFound : <var>public</var> std::runtime_error 
	{ 
	<var>public</var>: 
		URINotFound(<var>const</var> std::string&amp; Message = <kbd>"The specified URI was not found in the resource index."</kbd>)
			: runtime_error(Message) { } 
	};

	<cite>// thrown if a resource allocation fails</cite>
	<var>class</var> BadResourceAllocation : <var>public</var> std::runtime_error {
	<var>public</var>: 
		BadResourceAllocation(<var>const</var> std::string&amp; Message = <kbd>"Failed to allocate memory for resource."</kbd>)
			: runtime_error(Message) {}
	};
}

<var>template</var> &lt;<var>class</var> Resource&gt; <var>class</var> ResourceManagerB {
	<var>typedef</var> std::pair&lt;URI, Resource*&gt; ResourcePair;
	<var>typedef</var> std::map&lt;URI, Resource*&gt; ResourceList;

	<cite>// the list of the manager's resources</cite>
	ResourceList Resources;
<var>public</var>:
	~ResourceManagerB() { UnloadAll(); }

	<cite>// Load a resource with the specified URI</cite>
	<cite>// the URI could represent, e.g, a filename</cite>
	URI&amp; Load(URI&amp; Uri);
	<cite>// unload a resource with the specified URI</cite>
	<var>void</var> Unload(URI&amp; Uri);
	<cite>// unload all resources</cite>
	<var>void</var> UnloadAll();

	<cite>// get a pointer to a resource</cite>
	Resource* GetPtr(URI&amp; Uri);
	<cite>// get a reference to a resource</cite>
	Resource&amp; Get(URI&amp; Uri);
};

<var>template</var> &lt;<var>class</var> Resource&gt;
URI&amp; ResourceManagerB&lt;Resource&gt;::Load(URI&amp; Uri)
{
	<cite>// check if resource URI is already in list</cite>
	<cite>// and if it is, we do no more</cite>
	<var>if</var> (Resources.find(Uri) == Resources.end())
	{
		<cite>// try to allocate the resource</cite>
		<cite>// NB: if the Resource template argument does not have a</cite>
		<cite>// constructor accepting a const std::std::string, then this</cite>
		<cite>// line will cause a compiler error</cite>
		Resource* temp = <var>new</var> (std::nothrow) Resource(Uri);
		<cite>// check if the resource failed to be allocated</cite>
		<cite>// std::nothrow means that if allocation failed</cite>
		<cite>// temp will be 0</cite>
		<var>if</var> (!temp)
			<var>throw</var> Exceptions::BadResourceAllocation();
		<cite>// add the resource and it's URI to the manager's list</cite>
		Resources.insert(ResourcePair(Uri, temp));
	}
	<var>return</var> Uri;
}

<var>template</var> &lt;<var>class</var> Resource&gt;
<var>void</var> ResourceManagerB&lt;Resource&gt;::Unload(URI&amp; Uri)
{
	<cite>// try to find the specified URI in the list</cite>
	ResourceList::const_iterator itr = Resources.find(Uri);
	<cite>// if it is found...</cite>
	<var>if</var> (itr != Resources.end())
	{
		<cite>// ... deallocate it</cite>
		<var>delete</var> itr-&gt;second;
		<cite>// then remove it from the list</cite>
		Resources.erase(Uri);
	}
}

<var>template</var> &lt;<var>class</var> Resource&gt;
<var>void</var> ResourceManagerB&lt;Resource&gt;::UnloadAll()
{
	<cite>// iterate through every element of the resource list</cite>
	ResourceList::iterator itr;
	<var>for</var> (itr = Resources.begin(); itr != Resources.end(); itr++)
		<cite>// delete each resource</cite>
		<var>delete</var> itr-&gt;second;
	<cite>// finally, clear the list</cite>
	Resources.clear();
}

<var>template</var> &lt;<var>class</var> Resource&gt;
Resource* ResourceManagerB&lt;Resource&gt;::GetPtr(URI&amp; Uri)
{
	<cite>// find the specified URI in the list</cite>
	ResourceList::const_iterator itr;
	<cite>// if it is there...</cite>
	<var>if</var> ((itr = Resources.find(Uri)) != Resources.end())
		<cite>// ... return a pointer to the corresponding resource</cite>
		<var>return</var> itr-&gt;second;
	<cite>// ... else return 0</cite>
	<var>return</var> 0;
}

<var>template</var> &lt;<var>class</var> Resource&gt;
Resource&amp; ResourceManagerB&lt;Resource&gt;::Get(URI&amp; Uri)
{
	<cite>// get a pointer to the resource</cite>
	Resource* temp = GetPtr(Uri);
	<cite>// if the resource was found...</cite>
	<var>if</var> (temp)
		<cite>// ... dereference the pointer to return a reference</cite>
		<cite>// to the resource</cite>
		<var>return</var> *temp;
	<var>else</var>
		<cite>// ... else throw an exception to notify the caller that</cite>
		<cite>// the resource was not found</cite>
		<var>throw</var> Exceptions::URINotFound();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<br>
Another important aspect of your engine/framework is the interface. When you're writing the logic of the game itself it shouldn't take you 4 hours to write the main game loop as you search through the hundreds of update functions trying to figure out which ones you actually need. Keep it simple and concise. If you're able to update all game logic with one or two function calls and render the scene with one or two more you're on the right track. Taking advantage of object oriented principles, such as inheritance and pure virtual base classes (think <i>interfaces</i>) is a great way to create a framework with a sound structure.<br>
<br>
For example, a base class of all game objects could be defined as such:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br></code></pre></td>
<td class="source"><pre><code><var>class</var> GameObject
{
<var>public</var>:
    <var>virtual</var> ~GameObject()=0;

    <var>virtual</var> Vector2f getPosition();

    <var>virtual</var> <var>bool</var> interact(Object* o);

    <var>virtual</var> <var>void</var> draw(); <cite>//highly library dependent</cite>
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With all subclasses now being held to this interface it is possible to have one holding entity that can easily store and manage any and every object you define regardless of what the object actually is. As you learn and program more and more you'll find more ways of using the various features of your language of choice to your advantage. <br>
<br>
<br>
<hr>
<br>
<br>
<u><b>Step 5: Media (audio and graphics)</b></u>
<br>
By now you've hopefully at least thought about what you want the game to actually look like, and maybe you already have a set of media to work with. If you're anything like me, however, you got so excited and caught up in whatever "beautiful design" you've thought up that by the time you get it to the point of testing you don't have a single image for your creation to make dance on the screen. Now is a great time to start getting the resources that you need. If you're artistically inclined, that's awesome. If not, don't worry, hope is not lost. Massive quantities of free graphics and sound effects are just a Google search away. Audacity and GIMP are indispensable tools for editing whatever you get or create.<br>
<br>
<br>
<hr>
<br>
<br>
<u><b>Step 6: Write Your Game</b></u>
<br>
Once you have an engine chosen or your own framework to use you can get around to actually writing the game logic itself. Ideally you've read through this article in its entirety at least once before spending countless hours that you'll never get back on creating an "engine" that oversteps its role enough to be virtually unusable but not enough to be independently functional. Your framework should provide a base that structures object interaction (but doesn't necessarily define it) and handles all rendering and other low level details, such as physics. The game logic itself will define object interaction (by defining a subclass of GameObject for example), game rules (such as what constitutes winning or losing), the initial state of the game (which map is loaded first, what items you start with, etc) and will contain the <i>main game loop</i>.<br>
<br>
What on earth is the main game loop? Simply put: it's a loop, the main loop. Think of what gets repeated continually while the game is being played, those are the things contained in this mysterious loop. For example, every iteration the game should update all of the objects and then draw them all to the screen. Beyond updating and drawing, the main loop will also probably be responsible for timing. A game that updates too much will appear to be incredibly fast to the user, and most likely will be too hard. Think pong at the speed of light. Ideally this loop will use the framework you created earlier and will be quite simple itself. See the example below:<br>
<br>
<i>Game Loop:</i>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br></code></pre></td>
<td class="source"><pre><code><var>while</var> (!Game.playerLost())
{
    world.update(); <cite>//assume this world object owns all of the GameObjects and updates them as well</cite>

    screen.clear();
    world.draw(screen);
    screen.display();

    ensureProperFPS(); <cite>//just a placeholder, put the actual timing logic right here in the loop</cite>
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<br>
<hr>
<br>
<br>
<u><b>Step 7: Take something from it</b></u>
<br>
The main reason I talk about creating a framework separate from the game logic is for you to learn to write reusable code. Then I told you not to worry about making it actually reusable and instead focus on making the game. I stand to that, one of the main reasons beginners give up on projects is that they spend vast amounts of time and effort trying to "write an engine" for their game, but they don't really know yet what a good engine even includes or a structure/interface that will actually work. After wasting all of that time they have nothing to show, then get discouraged and quit as a result. By focusing on writing the game first, and reusable code second, you will ideally end up with something that you can see. A tangible reward for your effort and a reason to keep working harder. <br>
<br>
Now that you have a playable game that you're happy with you can try and make portable modules out of the game code. Did you write an awesome resource manager or fantastic class for handling keyboard input? Try and make them completely portable so you can just copy over the source files and use them right "out of the box" in other projects. If you want to start completely fresh in your next project, that's fine as well. You don't have to literally take code from  a project to have taken something from it. So long as you learned something in the process it was all worthwhile.<br>
<br>
<hr>
<br>
<br>
<u><b>Step 8: Package and Distribute</b></u>
<br>
After all of that work you'll probably want people to actually play your game! Package all of the required files into a zip file, compressed archive or executable installer and send it to everyone!<br>
<br>
<br>
<hr>
<br>
<br>
<u><b>Tips:</b></u>
<br>
I've learned many things about making games, some things the hard way. Here are some things that you should do:<br>
<ul>
<li>First, stay organized! You should have a good organizational system for everything; your code, your media, your documentation, etc. Folders exist for a reason, use them!</li>
<br>
<li>Also, try to keep your code clean and readable. Give functions meaningful names and keep everything as simple as possible</li>
<br>
<li>Document! I never really talked about it in the article, but document everything! Document the format for all of your data files and document what all of your functions and classes do. You have no idea how much time this saves and how many headaches it prevents until you do it</li>
<br>
<li>Start small. Don't try and create the next Pokemon game on your first go. Start with small, manageable projects and expand your goals in proportion with your skills. Trying to tackle a project over your head will only discourage you</li>
<br>
<li>Eye on the prize! One of the biggest downfalls to one too many projects of mine was me getting hung up on tiny details while neglecting the bigger picture. Yes, my clouds, rain and thunder, footprints and fog effects were all beautiful, but I never ended up with a finished game. You can make it pretty later, make the game first!</li>
<br>
<li>Have fun! The point of games is to have fun, and making them can be fun, too. It's always easier to accomplish a task if you enjoy yourself while working on it. Of course there will be times when you get frustrated, but if you find yourself getting overly angry, take a break! Taking a walk and thinking about something else is often the best solution to a problem. When you return you'll have a fresh start, which can allow you to find a solution that you may not have thought of while on your previous train of thought.</li>
</ul>
<br>
<small><i>Some starting tips from <b>chrisname</b>:</i></small>
<blockquote>You don't need to work that hard. What you need to do, is go through a programming tutorial (the one on this website for example). Don't do too much in a day, or you will get bored and unmotivated. Don't set a goal based on time, that doesn't work. You'll forget alot of what you learn if you stop halfway through a lesson. Work through the tutorial on this website ( <a href="http://cplusplus.com/doc/tutorial/">http://cplusplus.com/doc/tutorial/</a> ). Aim to get through two lessons a day. Don't stop partway through a lesson (unless it's for a short break, that's a good idea) and don't do too much in one go, or you simply won't remember it. I recommend reading and copying out each example (not copy and paste; type it yourself, this will help you to understand what you are doing), compiling it, seeing what it does when you run it and modifying things to see what changes. I also recommend you look at other people's code (one of the things that has helped me is to take other people's broken code and try to fix it, although don't get too hung up on this because it is hard to read other people's code when you first start out). When you are reading, try to rephrase things: "If you can't explain it simply, you don't understand it well enough." (Albert Einstein).<br>
<br>
Once you've gone through this tutorial, and maybe some others (I read about three different tutorials because it was useful to have things said in a different way - I find having something explained in two different ways is useful for understanding and remembering it), you could read through the tutorials for SFML ( <a href="http://sfml-dev.org/tutorials/1.6/">http://sfml-dev.org/tutorials/1.6/</a> ). Learning SFML will teach you to make 2D games. I'd also recommend learning SDL ( <a href="http://lazyfoo.net/SDL_tutorials/index.php">http://lazyfoo.net/SDL_tutorials/index.php</a> ) because lots of games use it and you will most probably come across it eventually.<br>
<br>
After that, you should get into OpenGL programming if you want to make 3D games. SFML makes this very easy, and the SFML tutorial includes a tutorial for using OpenGL. For OpenGL, perhaps someone here can recommend you a book or tutorial.<br>
<br>
<br>
<br>
Throughout all this you should remember that it is important to pace yourself. Don't try to absorb too much at once or you'll forget lots of it. And don't stay up until 3am when you have an exam the day after next... </blockquote>
</div></div><div id="CH_bb"></div><div id="CH_scoreapp"></div><script type="text/javascript">new Score('CH_scoreapp','/articles/score.cgi','1w6AC542');</script></div>
</div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="/info/">Information</a></li>
<li class="folder doc"><a href="/doc/">Tutorials</a></li>
<li class="folder reference"><a href="/reference/">Reference</a></li>
<li class="folder selected articles"><a href="/articles/">Articles</a></li>
<li class="folder forum"><a href="/forum/">Forum</a></li>
</ul>
</div>
<div class="sect">
<h3><b><a href="/articles/">Articles</a></b></h3>
<ul>
<li><a href="/articles/algorithms/">Algorithms</a></li><li><a href="/articles/cpp11/">C++ 11</a></li><li><a href="/articles/graphics/">Graphics and multimedia</a></li><li><a href="/articles/howto/">How-To</a></li><li><a href="/articles/language/">Language Features</a></li><li><a href="/articles/linux/">Unix/Linux programming</a></li><li><a href="/articles/sourcecode/">Source Code</a></li><li><a href="/articles/standard_library/">Standard Library</a></li><li><a href="/articles/tips/">Tips and Tricks</a></li><li><a href="/articles/tools/">Tools and Libraries</a></li><li><a href="/articles/visualcpp/">Visual C++</a></li><li><a href="/articles/winapi/">Windows API</a></li></ul>
</div>
<div id="I_subnav"></div>
</div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="/">Home page</a> | <a href="/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2016 - All rights reserved - <i>v3.1</i><br><a href="/contact.do?referrer=www.cplusplus.com%2Farticles%2F1w6AC542%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
onSession(function(us) {
		document.getElementById('I_subnav').innerHTML=
			us.ok?
				'<div class="sect"><h3><b><a href="/user/">'+us.user+'</a></b></h3><ul>'+
				'<li><a href="/articles/myitems.cgi">My items</a></li>'+
				(us.auth(32768)?'<li><a href="/articles/adminitems.cgi">Admin items</a></li>':'')+
				'</ul></div>'
			:'';
	}); onSession(function (us) {
		var el=document.getElementById('CH_bb'); el.innerHTML='';
		if ( (us.auth(32768)) || ((us.uniqid=='S2vDSL3A')&&(us.auth(128))) ) {
			el.appendChild(btn('Edit article','Edit this version of the article','edit','/articles/edit.cgi?a=1w6AC542'));
	
			if (us.auth(32768)) {
				el.appendChild(btn('Delete article','Delete this article','delete','javascript:artdel()'));
			}
	
		}
	});
	function artdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='/articles/delete.cgi?a=1w6AC542'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>