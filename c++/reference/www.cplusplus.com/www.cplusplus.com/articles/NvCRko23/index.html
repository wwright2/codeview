<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>A simple OpenGL animation with glfw, ste - C++ Articles</title>
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" type="text/css" href="/v321/main.css">
<script src="/v321/main.js" type="text/javascript"></script>
<script type='text/javascript'>
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
(function() {
var gads = document.createElement('script');
gads.async = true;
gads.type = 'text/javascript';
var useSSL = 'https:' == document.location.protocol;
gads.src = (useSSL ? 'https:' : 'http:') + 
'//www.googletagservices.com/tag/js/gpt.js';
var node = document.getElementsByTagName('script')[0];
node.parentNode.insertBefore(gads, node);
})();
</script>

<script type='text/javascript'>
googletag.cmd.push(function() {
googletag.defineSlot('/32882001/L', [728, 90], 'div-gpt-ad-1427191279638-0').addService(googletag.pubads());
googletag.enableServices();
});
</script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="/articles/">Articles</a></li>
<li class="here">A simple OpenGL animation with glfw, ste</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div id="I_content">
<div class="C_art">
<div id="I_author">Published by <b><a href="/user/biicode/" rel="author">biicode</a></b></div>
<div id="I_date">Dec 2, 2014 (last update: Dec 2, 2014)</div>
<h1>A simple OpenGL animation with glfw, step by step</h1>
<div id="I_score">Score: 3.9/5 (136 votes)</div>
<div id="I_stars"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star-half.png" width="16" height="16" alt="*"><img src="/ico/16star-empty.png" width="16" height="16" alt="*"></div>
<div id="I_content">
<i>Written by <a href="http://manu343726.github.io">Manu SÃ¡nchez</a>.</i> <br>
<br>
<a href="http://www.glfw.org/">glfw</a> is C a window management library for OpenGL applications, a replacement of the old and well known GLUT and freeGLUT libraries. The library is <a href="https://github.com/glfw/glfw">actively maintained</a>, and shipped with a great set of examples and docs.<br>
<br>
In this article, we will learn how to setup a OpenGL application easily thanks to glfw, with a simple animation simulating a small bouncing ball.<br>
<br>
<h3>An overview of the glfw API</h3>
<br>
glfw is a C API which relies on callbacks to handle the different configurations, events, errors, etc an OpenGL application would need. <br>
Also the multiple resources you may use, such as windows, OpenGL contexts, etc. are managed internally by the library, and it only provides you handles as identifiers of those resources.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>GLFWwindow* window = glfwCreateWindow(640, 480, <kbd>"My Title"</kbd>, NULL, NULL);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here the <code>window</code> variable is just a handle to the window you requested with a call to <code>glfwCreateWindow()</code> function. You are not responsible of releasing the window resource manually, since its managed by the library. Of course you can, if you want to delete that window for whatever reason:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>glfwDestroyWindow(window);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
After that call, the `window` handle becomes invalid, and the window it represents is closed.<br>
<br>
The point of this kind of design is that <b>the library manages the resources, you only use them</b>. So there are no resource leaks. You can customize the interaction with those resources via the callbacks the API provides. <br>
<br>
For example: What happens when my window is resized? I need to rearrange the viewport of my OpenGL render! Don't worry, you can say glfw what to do in that case, just setting up a callback:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>void</var> framebuffer_size_callback(GLFWwindow* window, <var>int</var> width, <var>int</var> height)
{
    glViewport(0, 0, width, height);
}

glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<h3>Our goal: A little, funny, squishy, and so cute bouncing ball</h3>
<br>
Let's write a simple animation of a white bouncing ball. I'm not a game designer, the goal here is to have the animation working with a couple of lines only.   <br>
<br>
Apologizes in advance to anyone who's eyes hurt after watching this image:<br>
<br>
<img src="Captura.png" alt="">
<i>As I said, I'm a programmer...</i>
<br>
<h3>A glfw application with C++11</h3>
glfw has a C API. That's fine, but I'm a C++ programmer. Let's wrap this API in a simple inheritance-based little framework.<br>
<br>
<h4>The <code>glfw_app</code> base class</h4>
<br>
What I propose is a simple design to delegate all the repetitive tasks on the base class, and then create a custom glfw-based OpenGL application in a simple way, just inheriting and customizing what you need via polymorphism.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></pre></td>
<td class="source"><pre><code><var>class</var> glfw_app 
{
<var>public</var>:
    glfw_app(<var>const</var> std::string&amp; window_title, <var>int</var> window_width, <var>int</var> window_height);
    <var>virtual</var> ~glfw_app();
    
    <var>void</var> start();

    <var>virtual</var> <var>void</var> on_keydown(GLFWwindow* window, <var>int</var> key, <var>int</var> scancode, <var>int</var> action, <var>int</var> mods);
    <var>virtual</var> <var>void</var> on_error(<var>int</var> error, <var>const</var> <var>char</var>* desc);
    <var>virtual</var> <var>void</var> on_resize(GLFWwindow* window, <var>int</var> width, <var>int</var> height);
    <var>virtual</var> <var>void</var> glloop() = 0;
    
    GLFWwindow* window() <var>const</var>;
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This base class is simple: It manages a glfw window and their OpenGL context for us, wraps (and currently hides) the event and rendering loop, finally and provides us some polymorphic functions to say what to do when a key is pressed, when the window is resized, etc. <br>
<br>
Take the most simple glfw example, a simple triangle (Extracted from <a href="http://www.glfw.org/docs/latest/quick.html#quick_example">glfw docs</a>). It can be written with a couple of lines thanks to our <code>glfw_class</code> class:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></pre></td>
<td class="source"><pre><code><var>void</var> triangle::on_keydown(GLFWwindow* window, <var>int</var> key, <var>int</var> scancode, <var>int</var> action, <var>int</var> mods)
{
	<var>if</var> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GL_TRUE);
}

<var>void</var> triangle::glloop()
{
	<var>float</var> ratio = glfw_app::framebuffer_width() / (<var>float</var>)glfw_app::framebuffer_height();

	glClear(GL_COLOR_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-ratio, ratio, -1.f, 1.f, 1.f, -1.f);
	glMatrixMode(GL_MODELVIEW);

	glLoadIdentity();
	glRotatef((<var>float</var>)glfwGetTime() * 50.f, 0.f, 0.f, 1.f);

	glBegin(GL_TRIANGLES);
	glColor3f(1.f, 0.f, 0.f);
	glVertex3f(-0.6f, -0.4f, 0.f);
	glColor3f(0.f, 1.f, 0.f);
	glVertex3f(0.6f, -0.4f, 0.f);
	glColor3f(0.f, 0.f, 1.f);
	glVertex3f(0.f, 0.6f, 0.f);
	glEnd();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
That's all! All the other things (Buffer swapping, window and gl context management, etc.) is done by the base class. How? Let's see it step by step.<br>
<br>
<h4>Resource management</h4>
<br>
As we have seen above, the <code>glfw_app</code> class is designed to manage one glfw window and its corresponding OpenGl setup. In that way, all the glfw/OpenGL setup is done in the constructor of the class, and all the cleanup on the destructor:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></code></pre></td>
<td class="source"><pre><code>glfw_app::glfw_app(<var>const</var> std::string&amp; window_title , <var>int</var> window_width , <var>int</var> window_height)
{
    <var>if</var>( !glfwInit() )
        <var>throw</var> std::runtime_error
    {
        <kbd>"Unable to initialize glfw runtime"</kbd>
    };

    _window = glfwCreateWindow(window_width , window_height , window_title.c_str() , <var>nullptr</var> , <var>nullptr</var>);

    <var>if</var>( !_window )
        <var>throw</var> std::runtime_error
    {
        <kbd>"Unable to initialize glfw window"</kbd>
    };

    glfwMakeContextCurrent(_window);
    glfwSwapInterval(1);
}

glfw_app::~glfw_app()
{
    glfwDestroyWindow(_window);
    glfwTerminate();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The class acts as a singleton: There is only one <code>glfw_app</code> instance per application since there's only one glfw application (The app itself).<br>
<br>
<h4>Main loop</h4>
<br>
The main loop is encapsulated. This makes it simpler to write a custom OpenGL application, since in most of the cases this loop is almost the same (Fetch events, render, swap buffers):<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><var>void</var> glfw_app::start()
{
    glfwloop();
}

<var>void</var> glfw_app::glfwloop()
{
    <var>while</var>( !glfwWindowShouldClose(_window) )
    {
	    <cite>//Here we call our custom loop body</cite>
        <var>this</var>-&gt;glloop(); 

        glfwSwapBuffers(_window);
        glfwPollEvents();
    }
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<h4>Event handling</h4>
<br>
<code>glfw_app</code> has some polymorphic functions for event handling of the form <code>on_EVENT()</code>. They just wrap the original glfw callbacks, but customization via polymorphism is more natural to OOP programmers:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><var>void</var> glfw_app::on_keydown(GLFWwindow* window , <var>int</var> key , <var>int</var> scancode , <var>int</var> action , <var>int</var> mods) 
{
    <cite>//Does nothing by default. Override to customize</cite>
}

<var>void</var> glfw_app::on_error(<var>int</var> error , <var>const</var> <var>char</var>* desc) 
{
    <cite>//Does nothing by default</cite>
}

<var>void</var> glfw_app::on_resize(GLFWwindow* window , <var>int</var> width , <var>int</var> height)
{
    <cite>//By defualt rearranges OpenGL viewport to the current framebuffer size.</cite>

    glViewport(0 , 0 , width , height);
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<h3>Callback API vs OOP</h3>
<br>
Is not that easy. We cannot just pass polymorphic functions to C callbacks, since they are not convertible to plain function objects. That makes sense, since (even ignoring the dynamic dispatching part) they need an object to be called with.<br>
<br>
To be able to inject these polymorphic functions as callbacks for the glfw API, we need a bridge between the C and the C++ world. `static` member functions!<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></pre></td>
<td class="source"><pre><code><var>class</var> glfw_app_manager
{
    <var>static</var> glfw_app* _app;
    
    <var>static</var> <var>void</var> on_keydown(GLFWwindow* window, <var>int</var> key, <var>int</var> scancode, <var>int</var> action, <var>int</var> mods)
    {
        <var>if</var>(_app) _app-&gt;on_keydown(window,key,scancode,action,mods);
    }
    
    <var>static</var> <var>void</var> on_error(<var>int</var> error, <var>const</var> <var>char</var>* desc)
    {
        <var>if</var>(_app) _app-&gt;on_error(error,desc);
    }
    
    <var>static</var> <var>void</var> on_resize(GLFWwindow* window, <var>int</var> width, <var>int</var> height)
    {
        <var>if</var>(_app) _app-&gt;on_resize(window,width,height);
    }
    
<var>public</var>:
    <var>static</var> <var>void</var> start_app(glfw_app* app)
    {
        _app = app;
        
        glfwSetKeyCallback(app-&gt;window() , on_keydown);
        glfwSetFramebufferSizeCallback(app-&gt;window() , on_resize);
        glfwSetErrorCallback(on_error);
    }
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
As I said previously, our app class is actually a singleton. The <code>glfw_app_manager</code> class is the one managing it. Stores the current app instance, registers our bridges as callbacks, and then calls our app functions on them.<br>
<br>
Finally, put a bit of dressing to our little framework by writing a function template to easy instance glfw applications:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><var>template</var>&lt;<var>typename</var> T , <var>typename</var>... ARGS , <var>typename</var> = <var>typename</var> std::enable_if&lt;std::is_base_of&lt;glfw_app,T&gt;::value&gt;::type&gt;
std::unique_ptr&lt;T&gt; make_app(ARGS&amp;&amp;... args)
{
    std::unique_ptr&lt;T&gt; app{ <var>new</var> T{ std::forward&lt;ARGS&gt;(args)...} };
    
    glfw_app_manager::start_app(app.get());
    
    <var>return</var> app;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Using that, setting up a glfw application can be as easy as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><dfn>#include "glfw_app.hpp"</dfn>
<dfn>#include "your_glfw_app.hpp"</dfn>

<var>int</var> main()
{
    <var>auto</var> app = make_app&lt;your_glfw_app&gt;(<kbd>"glfw!"</kbd> , 800 , 600);
    
    app-&gt;start();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<h3>TL;DR. Show me the ball!</h3>
<br>
Here's the declaration of the bouncing ball glfw application:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><var>class</var> ball : <var>public</var> glfw_app
{
<var>public</var>:
	<var>template</var>&lt;<var>typename</var>... ARGS&gt;
	ball(ARGS&amp;&amp;... args) : glfw_app{ std::forward&lt;ARGS&gt;(args)... } , 
		x_ball{ 0.0f },
		y_ball{ 0.8f },
		vx_ball{ 0.0f },
		vy_ball{ 0.0f }
	{}

	<var>virtual</var> <var>void</var> on_keydown(GLFWwindow* window, <var>int</var> key, <var>int</var> scancode, <var>int</var> action, <var>int</var> mods) override;

	<var>virtual</var> <var>void</var> glloop() override;

<var>private</var>:
	<var>float</var> x_ball, y_ball;
	<var>float</var> vx_ball, vy_ball;
	<var>const</var> <var>float</var> gravity = 0.01;
	<var>const</var> <var>float</var> radius = 0.05f;

	<var>void</var> draw_ball();
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
We have ball coordinates, ball speed, and its radius. There is also a `gravity` constant, since we want our ball to bounce.  <br>
The template stuff on the constructor is a variadic template with perfect forwarding, just to bypass all the arguments to the base class constructor.<br>
<br>
The <code>on_keydon()</code> callback is not complex: Just closes the window when the user presses <kbd>ESC</kbd>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>void</var> ball::on_keydown(GLFWwindow* window, <var>int</var> key, <var>int</var> scancode, <var>int</var> action, <var>int</var> mods)
{
	<var>if</var> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GL_TRUE);
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Now let's see the body of our rendering loop:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><var>void</var> ball::glloop()
{
	<var>float</var> ratio = framebuffer_width() / (<var>float</var>)framebuffer_height();

	glClear(GL_COLOR_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-ratio, ratio, -1.f, 1.f, 1.f, -1.f);
	glMatrixMode(GL_MODELVIEW);

	<cite>//Bounce on window bottom</cite>
	<var>if</var> (y_ball + radious &lt;= radious)
		vy_ball = std::abs(vy_ball);
	<var>else</var>
		vy_ball -= gravity; <cite>//Apply gravity</cite>

	<cite>//Update ball coordinates</cite>
	x_ball += vx_ball;
	y_ball += vy_ball;

	<cite>//Lets draw the ball!</cite>
	draw_ball();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note how the ball is projected. The visible area of our OpenGL scene (The area which matches the viewport) goes from -1 to 1 in both axes, where -1 is the bottom-left corner of our window, and 1 is its top-left.  <br>
Working with coordinates [-1,1] makes it simple to deal with window bounds, since they are independent of the window's size.<br>
<br>
Check how the animation works:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></code></pre></td>
<td class="source"><pre><code>	<cite>//Bounce on window bottom</cite>
	<var>if</var> (y_ball - radious &lt;= - 1)
		vy_ball = std::abs(vy_ball);
	<var>else</var>
		vy_ball -= gravity; <cite>//Apply gravity</cite>

	<cite>//Update ball coordinates</cite>
	x_ball += vx_ball;
	y_ball += vy_ball;

	<cite>//Lets draw the ball!</cite>
	draw_ball();</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The ball's position and speed are updated following the equations <code>v' = v + a*t</code> and <code>p' = p + v * t</code>, where <code>v</code> is velocity (speed), <code>a</code> is acceleration (The <code>gravity</code> constant), and <code>t</code> is time. <br>
<br>
Time is measured in frames, so in all the equations <code>t</code> is one. That's why there's no <code>t</code> in our code. <b>If you want a stable simulation (independent of frame rate) you should use a more complex technique, like those described in <a href="http://gafferongames.com/game-physics/fix-your-timestep/">this article</a>.</b>
<br>
If the ball goes out of the window bounds, that is, <code>y_ball - radious</code> is less than -1, we should make the ball go upwards: Set its vertical speed as positive:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>if</var> (y_ball - radious &lt;= - 1)
    vy_ball = std::abs(vy_ball);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Also apply gravity. Don't apply acceleration when the ball bounces. <br>
<br>
The final step is to draw the ball: Draw a white "circle" (a regular polygon) using <code>GL_POLYGON</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><var>void</var> ball::draw_ball()
{
	<var>const</var> <var>float</var> full_angle = 2.0f*3.141592654f;
	<var>float</var> x, y;

	glBegin(GL_POLYGON);
	glColor3f(1.0f, 1.0f, 1.0f);

	<var>for</var> (std::size_t i = 0; i &lt; 20; ++i)
	{
		x = x_ball + radious*(std::cos(i*full_angle / 20.0f));
		y = y_ball + radious*(std::sin(i*full_angle / 20.0f));

		glVertex2f(x, y);
	}

	glEnd();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
That's all! Now start our ball app:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><dfn>#include "glfw_app.hpp"</dfn>
<dfn>#include "ball.hpp"</dfn>

<var>int</var> main()
{
    <var>auto</var> app = make_app&lt;ball&gt;(<kbd>"bouncing ball!"</kbd> , 800 , 600);
    
    app-&gt;start();
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<h3>Build and run the example</h3>
<br>
<a href="https://www.biicode.com">biicode</a> is a dependency manager for C and C++, in the same way as pip for python or Maven for Java. They provide a block (package) with the glfw library, so making our example running accross multiple platforms is so easy.  <br>
Our bouncing ball example was released as the  <a href="https://www.biicode.com/manu343726/glfw-example"><code>manu343726/glfw-example</code></a> block. Open and run it is as easy as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
$ bii init biicode_project
$ cd biicode_project
$ bii open manu343726/glfw_example
$ bii cpp:configure
$ bii cpp:build
$ ./bin/manu343726_glfw-example_main
</samp></pre></td></tr></table></div>
<br>
<b>Build may fail on linux platforms if you have some X11 libraries required by glfw not installed. They are checked during <code>bii cpp:configure</code>, follow its output if something goes wrong.<br>
<br>
Also note the code snippets of this article target C++11, so you should use a C++11 compliant compiler like GCC 4.8.1 (Shipped by default by Ubuntu 14.04 and the latest MinGW for Windows), Clang 3.3, or Visual Studio 2013.</b>
<br>
Finally, if you want to try more glfw examples, the guys at biicode have a <a href="https://www.biicode.com/examples/examples/glfw/master/0/particles.c"><code>examples/glfw</code></a> block with a complete set of examples extracted from the original glfw distribution.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
$ bii open examples/glfw
$ bii cpp:configure
$ bii cpp:build
$ ./bin/examples_glfw_particles
</samp></pre></td></tr></table></div>
<br>
<h3>Summary</h3>
<br>
glfw is a great library to write OpenGL applications. Its C API is clear and simple, and making it work in  the C++ way can be done with just a little effort.   <br>
We learnt here how to make a little framework to write simple OpenGL applications in a OO way. Encapsulating the most common tasks in a base class reduces noise in our simple OpenGL examples.<br>
</div></div><div id="CH_bb"></div><div id="CH_scoreapp"></div><script type="text/javascript">new Score('CH_scoreapp','/articles/score.cgi','NvCRko23');</script></div>
</div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="/info/">Information</a></li>
<li class="folder doc"><a href="/doc/">Tutorials</a></li>
<li class="folder reference"><a href="/reference/">Reference</a></li>
<li class="folder selected articles"><a href="/articles/">Articles</a></li>
<li class="folder forum"><a href="/forum/">Forum</a></li>
</ul>
</div>
<div class="sect">
<h3><b><a href="/articles/">Articles</a></b></h3>
<ul>
<li><a href="/articles/algorithms/">Algorithms</a></li><li><a href="/articles/cpp11/">C++ 11</a></li><li><a href="/articles/graphics/">Graphics and multimedia</a></li><li><a href="/articles/howto/">How-To</a></li><li><a href="/articles/language/">Language Features</a></li><li><a href="/articles/linux/">Unix/Linux programming</a></li><li><a href="/articles/sourcecode/">Source Code</a></li><li><a href="/articles/standard_library/">Standard Library</a></li><li><a href="/articles/tips/">Tips and Tricks</a></li><li><a href="/articles/tools/">Tools and Libraries</a></li><li><a href="/articles/visualcpp/">Visual C++</a></li><li><a href="/articles/winapi/">Windows API</a></li></ul>
</div>
<div id="I_subnav"></div>
</div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="/">Home page</a> | <a href="/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2016 - All rights reserved - <i>v3.1</i><br><a href="/contact.do?referrer=www.cplusplus.com%2Farticles%2FNvCRko23%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
onSession(function(us) {
		document.getElementById('I_subnav').innerHTML=
			us.ok?
				'<div class="sect"><h3><b><a href="/user/">'+us.user+'</a></b></h3><ul>'+
				'<li><a href="/articles/myitems.cgi">My items</a></li>'+
				(us.auth(32768)?'<li><a href="/articles/adminitems.cgi">Admin items</a></li>':'')+
				'</ul></div>'
			:'';
	}); onSession(function (us) {
		var el=document.getElementById('CH_bb'); el.innerHTML='';
		if ( (us.auth(32768)) || ((us.uniqid=='E1p9LyTq')&&(us.auth(128))) ) {
			el.appendChild(btn('Edit article','Edit this version of the article','edit','/articles/edit.cgi?a=NvCRko23'));
	
			if (us.auth(32768)) {
				el.appendChild(btn('Delete article','Delete this article','delete','javascript:artdel()'));
			}
	
		}
	});
	function artdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='/articles/delete.cgi?a=NvCRko23'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>