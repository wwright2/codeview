<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Integer overflow - C++ Articles</title>
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" type="text/css" href="/v321/main.css">
<script src="/v321/main.js" type="text/javascript"></script>
<script type='text/javascript'>
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
(function() {
var gads = document.createElement('script');
gads.async = true;
gads.type = 'text/javascript';
var useSSL = 'https:' == document.location.protocol;
gads.src = (useSSL ? 'https:' : 'http:') + 
'//www.googletagservices.com/tag/js/gpt.js';
var node = document.getElementsByTagName('script')[0];
node.parentNode.insertBefore(gads, node);
})();
</script>

<script type='text/javascript'>
googletag.cmd.push(function() {
googletag.defineSlot('/32882001/L', [728, 90], 'div-gpt-ad-1427191279638-0').addService(googletag.pubads());
googletag.enableServices();
});
</script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="/articles/">Articles</a></li>
<li class="here">Integer overflow</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div id="I_content">
<div class="C_art">
<div id="I_author">Published by <b><a href="/user/eklavya_sharma_2/" rel="author">eklavya sharma 2</a></b></div>
<div id="I_date">Jun 9, 2012 (last update: Jun 8, 2014)</div>
<h1>Integer overflow</h1>
<div id="I_score">Score: 3.6/5 (193 votes)</div>
<div id="I_stars"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star-half.png" width="16" height="16" alt="*"><img src="/ico/16star-empty.png" width="16" height="16" alt="*"></div>
<div id="I_content">
Overflow is a phenomenon where operations on 2 numbers exceeds the maximum (or goes below the minimum) value the data type can have. Usually it is thought that integral types are very large and people don't take into account the fact that sum of two numbers can be larger than the range. But in things like scientific and mathematical computation, this can happen. For example, an unhandled arithmetic overflow in the engine steering software was the primary cause of the crash of the maiden flight of the Ariane 5 rocket. The software had been considered bug-free since it had been used in many previous flights; but those used smaller rockets which generated smaller accelerations than Ariane 5's.This article will tell how this problem can be tackled.<br>
<br>
In this article, we will only deal with integral types (and not with types like float and double)<br>
<br>
In order to understand how to tackle this problem we will first know how numbers are stored.<br>
<br>
<b><h3>About integers:</h3></b>
<br>
If the size of a data type is n bytes, it can store 2<sup>8n</sup> different values. This is called the data type's range.<br>
If size of an unsigned data type is n bytes, it ranges from 0 to 2<sup>8n</sup>-1<br>
If size of a signed data type is n bytes, it ranges from -2<sup>8n-1</sup> to 2<sup>8n-1</sup>-1<br>
So, a short(usually 2 bytes) ranges from -32768 to 32767 and an unsigned short ranges from 0 to 65535<br>
<br>
Consider a short variable having a value of 250.<br>
It is stored int the computer like this (in binary format)<br>
00000000 11111010<br>
<br>
Complement of a number is a number with its bits toggled. It is denoted by ~<br>
For eg. ~250 is 11111111 00000101<br>
<br>
Negative numbers are stored using 2's complement system. According to this system, -n=~n+1<br>
-250 is stored as 11111111 00000110<br>
<a href="http://stackoverflow.com/questions/1049722/what-is-2s-complement">http://stackoverflow.com/questions/1049722/what-is-2s-complement</a>
<br>
<br>
10000000 00000000 (-32768) has no positive counterpart. Its negative is the number itself (try -n=~n+1)<br>
<br>
11100010 01110101 will be read as 57973 if data type is unsigned while it will be read as -7563 if data type is signed. If you add 65536 (which is the range) to -7563, you get 57973.<br>
<br>
<b>Overflow:</b>
<br>
Consider a data type var_t of 1 byte (range is 256):<br>
signed var_t a,b;<br>
unsigned var_t c,d;<br>
<br>
If c is 200(11001000) and d is 100(01100100), c+d is 300(00000001 00101100), which is more than the max value 255(11111111). 00000001 00101100 is more than a byte, so the higher byte will be rejected and c+d will be read as 44. So, 200+100=44! This is absurd! (Note that 44=300-256). This is an example of an unsigned overflow, where the value couldn't be stored in the available no. of bytes. In such overflows, the result is moduloed by range (here, 256).<br>
<br>
If a is 100(01100100) and b is 50(00110010), a+b is 150(10010110), which is more than the max value 127. Instead, a+b will be read as -106 (note that -106=150-256). This is an example of a signed overflow, where result is moduloed by range(here, 256).<br>
<br>
<b><h3>Detecting overflow:</h3></b>
<br>
Division and modulo can never generate an overflow.<br>
<br>
<b>Addition overflow:</b>
<br>
Overflow can only occur when sign of numbers being added is the same (which will always be the case in unsigned numbers)<br>
signed overflow can be easily detected by seeing that its sign is opposite to that of the operands.<br>
<br>
Let us analyze overflow in unsigned integer addition.<br>
<br>
Consider 2 variables a and b of a data type with size n and range R.<br>
Let + be actual mathematical addition and a$b be the addition that the computer does.<br>
<br>
If a+b&lt;=R-1, a$b=a+b<br>
As a and b are unsigned, a$b is more or equal to than both a and b.<br>
<br>
If a+b&gt;=R a$b=a+b-R<br>
as R is more than both a and b, a-R and b-R are negative<br>
So, a+b-R&lt;a and a+b-R&lt;b<br>
Therefore, a$b is less than both a and b.<br>
<br>
This difference can be used to detect unsigned addition overflow. a-b can be treated as a+(-b) hence subtraction can be taken care of in the same way.<br>
<br>
<b>Multiplication overflow:</b>
There are two ways to detect an overflow:<br>
<br>
1.	if a*b&gt;max, then a&gt;max/b (max is R-1 if unsigned and R/2-1 if signed).<br>
2.	Let there be a data type of size n and range R called var_t and a data type of size 2n called var2_t.<br>
Let there be 2 variables of var_t called a and b. Range of var2_t will be R*R, which will always be more than the product of a and b. hence if var2_t(a)*var2_t(b)&gt;R overflow has happened.<br>
<br>
<b>Truncation:</b>
This happens when a shorter is assigned from a longer variable. For eg, <span class="auto"><code class="source"><var>short</var> a;<var>long</var> b=70000;a=b;</code></span>
Only the lower bits are copied and the value's meaning is translated.<br>
<span class="auto"><code class="source"><var>short</var> a;<var>int</var> b=57973;a=b;</code></span> will also show this behaviour become -7563.<br>
Similar behaviour will be shown if int is replaced by unsigned short.<br>
<br>
<b>Type conversion:</b>
consider <span class="auto"><code class="source"><var>unsigned</var> <var>int</var> a=4294967290;<var>int</var> b=-6; <var>return</var> (a==b);</code></span>
This returns 1.<br>
Whenever an operation is performed between an unsigned and a signed variable of the same type, operands are converted to unsigned.<br>
Whenever an operation is performed between a long type and a short type, operands are converted to the long type.<br>
The above code returned 1 as a and b were converted to unsigned int and then compared.<br>
If we used __int64 (a 64-bit type) instead of unsigned int and 18446744073709551610 instead of 4294967290, the result would have been the same.<br>
<br>
<b>Type promotion:</b>
Whenever an operation is performed on two variables of a type shorter than int, the type of both variables is converted to int. For eg. <span class="auto"><code class="source"><var>short</var> a=32000,b=32000;cout&lt;&lt;a+b&lt;&lt;endl;</code></span> would display 64000, which is more than the max value of short. The reason is that a and b were converted to int and a+b would return an int, which can have a value of 64000.<br>
<br>
<b><h3>Libraries:</h3></b>
Microsoft Visual C++ 2010 has a header file safeint.h which has functions like safeadd,safesubtract,etc. It is a templated header file (and hence header only).</div></div><div id="CH_bb"></div><div id="CH_scoreapp"></div><script type="text/javascript">new Score('CH_scoreapp','/articles/score.cgi','DE18T05o');</script></div>
</div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="/info/">Information</a></li>
<li class="folder doc"><a href="/doc/">Tutorials</a></li>
<li class="folder reference"><a href="/reference/">Reference</a></li>
<li class="folder selected articles"><a href="/articles/">Articles</a></li>
<li class="folder forum"><a href="/forum/">Forum</a></li>
</ul>
</div>
<div class="sect">
<h3><b><a href="/articles/">Articles</a></b></h3>
<ul>
<li><a href="/articles/algorithms/">Algorithms</a></li><li><a href="/articles/cpp11/">C++ 11</a></li><li><a href="/articles/graphics/">Graphics and multimedia</a></li><li><a href="/articles/howto/">How-To</a></li><li><a href="/articles/language/">Language Features</a></li><li><a href="/articles/linux/">Unix/Linux programming</a></li><li><a href="/articles/sourcecode/">Source Code</a></li><li><a href="/articles/standard_library/">Standard Library</a></li><li><a href="/articles/tips/">Tips and Tricks</a></li><li><a href="/articles/tools/">Tools and Libraries</a></li><li><a href="/articles/visualcpp/">Visual C++</a></li><li><a href="/articles/winapi/">Windows API</a></li></ul>
</div>
<div id="I_subnav"></div>
</div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="/">Home page</a> | <a href="/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2016 - All rights reserved - <i>v3.1</i><br><a href="/contact.do?referrer=www.cplusplus.com%2Farticles%2FDE18T05o%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
onSession(function(us) {
		document.getElementById('I_subnav').innerHTML=
			us.ok?
				'<div class="sect"><h3><b><a href="/user/">'+us.user+'</a></b></h3><ul>'+
				'<li><a href="/articles/myitems.cgi">My items</a></li>'+
				(us.auth(32768)?'<li><a href="/articles/adminitems.cgi">Admin items</a></li>':'')+
				'</ul></div>'
			:'';
	}); onSession(function (us) {
		var el=document.getElementById('CH_bb'); el.innerHTML='';
		if ( (us.auth(32768)) || ((us.uniqid=='3TRfSL3A')&&(us.auth(128))) ) {
			el.appendChild(btn('Edit article','Edit this version of the article','edit','/articles/edit.cgi?a=DE18T05o'));
	
			if (us.auth(32768)) {
				el.appendChild(btn('Delete article','Delete this article','delete','javascript:artdel()'));
			}
	
		}
	});
	function artdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='/articles/delete.cgi?a=DE18T05o'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>