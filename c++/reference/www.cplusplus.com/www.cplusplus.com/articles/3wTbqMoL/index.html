<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>How to Handle exception at C++ construct - C++ Articles</title>
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" type="text/css" href="/v321/main.css">
<script src="/v321/main.js" type="text/javascript"></script>
<script type='text/javascript'>
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
(function() {
var gads = document.createElement('script');
gads.async = true;
gads.type = 'text/javascript';
var useSSL = 'https:' == document.location.protocol;
gads.src = (useSSL ? 'https:' : 'http:') + 
'//www.googletagservices.com/tag/js/gpt.js';
var node = document.getElementsByTagName('script')[0];
node.parentNode.insertBefore(gads, node);
})();
</script>

<script type='text/javascript'>
googletag.cmd.push(function() {
googletag.defineSlot('/32882001/L', [728, 90], 'div-gpt-ad-1427191279638-0').addService(googletag.pubads());
googletag.enableServices();
});
</script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="/articles/">Articles</a></li>
<li class="here">How to Handle exception at C++ construct</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div id="I_content">
<div class="C_art">
<div id="I_author">Published by <b><a href="/user/somenath_mukhopadhyay/" rel="author">somenath mukhopadhyay</a></b></div>
<div id="I_date">Nov 16, 2011 (last update: Nov 30, 2011)</div>
<h1>How to Handle exception at C++ constructor using Boost's Shared Ptr</h1>
<div id="I_score">Score: 3.2/5 (117 votes)</div>
<div id="I_stars"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star.png" width="16" height="16" alt="*"><img src="/ico/16star-empty.png" width="16" height="16" alt="*"><img src="/ico/16star-empty.png" width="16" height="16" alt="*"></div>
<div id="I_content">
Its a very common problem in C++ that if a class's constructor throws an exception (say memory allocation exception) how we should handle it. Think about the following piece of code. Here class A's constructor has thrown an exception.. so the best way to handle such situation is to instantiate A inside a try block...if exception is thrown in the constructor of A, i will be destroyed by stack unwinding and the thrown exception will be caught...<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br></code></pre></td>
<td class="source"><pre><code><var>class</var> MyException(string str){
<var>private</var>: 
string  msg;
<var>public</var>:
MyException(string str){
msg = str;
}
<var>void</var> printerrmsg(){
cout&lt;&lt;msg.c_str()&lt;&lt;endl;
}
}

<var>class</var> A{
<var>private</var>: <var>int</var> i;

<cite>//if exception is thrown in the constructor of A, i will de destroyed by stack unwinding</cite>
<cite>//and the thrown exception will be caught</cite>
A()
{
i = 10;
<var>throw</var> MyException(“Exception thrown in constructor of A()”);
}
};
<var>void</var> main(){
<var>try</var>{
A();
}
<var>catch</var>(MyException&amp; e){
e.printerrmsg();
}
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
now there is another point... suppose we need to allocate some dynamic memory in the constructor... and while doing that the constructor throws a memory exception... so the stack based pointer which was referencing the heap based memory will be destroyed because of the stack unwinding... so we will have some memory which is referenced by no pointer and hence we cannot access that... so obviously its a memory leak...  so, how can we handle that...<br>
<br>
the best way to handle this kind of situation in modern C++ is to use auto_ptr/shared_ptr... so the solution will look something as the following:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;memory&gt;</dfn>
<dfn>#include &lt;boost/shared_ptr.hpp&gt;</dfn>
<dfn>#include &lt;boost/shared_array.hpp&gt;</dfn>

<var>using</var> <var>namespace</var> std;

<var>class</var> SomeClass{
<var>public</var>:
 SomeClass(){}
 ~SomeClass(){};
};

<var>typedef</var> boost::shared_ptr&lt;SomeClass&gt; pSomeClass;
<var>typedef</var> boost::shared_ptr&lt;<var>char</var>&gt; pChar;
<var>typedef</var> boost::shard_array&lt;<var>char</var>&gt; charBuff;

<var>class</var> MyException{
<var>public</var>:
 MyException(string str){
 msg = str;
 }
 <var>void</var> printerrmsg(){
  cout&lt;&lt;msg.c_str()&lt;&lt;endl;
 }
<var>private</var>:
 string msg;
};
<var>class</var> A{
<var>private</var>:
 <var>int</var> i;
 pChar m_ptrChar;
 pSomeClass m_ptrSomeClass;
 charBuff m_pcharBuff;

 <cite>//if exception is thrown in the constructor of A, i will be destroyed by stack unwinding</cite>
 <cite>//and the thrown exception will be caught</cite>
<var>public</var>:
 A():m_ptrChar(<var>new</var> <var>char</var>),m_ptrSomeClass(<var>new</var> SomeClass),m_pcharBuff(<var>new</var> <var>char</var>[100])
 {
 i = 10;
 <var>throw</var> MyException(<kbd>"Exception at A's constructor"</kbd>);
 }
};

<var>int</var> main(){
 <var>try</var>{
 A objA;
 }
 <var>catch</var>(MyException&amp; e){
  e.printerrmsg();
 }
 <var>return</var> 1;
 }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
In Symbian C++, it is handled by a concept called two phase constructor... (it came into the picture because there was no template concept in earlier Symbian C++, and hence there was no auto_ptr)... in this process, if we want to create a dynamic memory allocation at the heap pointed by say *pMem, then in the first phase of construction we initialize the *pMem by NULL. obviously this cannot throw exception... we then push this pMem to the cleanupstack (this is a new concept of Symbian C++)... and in the second phase of construction, we allocate memory pointed by pMem... so, if the constructor fails, we still have a reference of pMem in the cleanupstack... we just need to pop it and destroy it... hence there is no chance of memory leak...</div></div><div id="CH_bb"></div><div id="CH_scoreapp"></div><script type="text/javascript">new Score('CH_scoreapp','/articles/score.cgi','3wTbqMoL');</script></div>
</div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="/info/">Information</a></li>
<li class="folder doc"><a href="/doc/">Tutorials</a></li>
<li class="folder reference"><a href="/reference/">Reference</a></li>
<li class="folder selected articles"><a href="/articles/">Articles</a></li>
<li class="folder forum"><a href="/forum/">Forum</a></li>
</ul>
</div>
<div class="sect">
<h3><b><a href="/articles/">Articles</a></b></h3>
<ul>
<li><a href="/articles/algorithms/">Algorithms</a></li><li><a href="/articles/cpp11/">C++ 11</a></li><li><a href="/articles/graphics/">Graphics and multimedia</a></li><li><a href="/articles/howto/">How-To</a></li><li><a href="/articles/language/">Language Features</a></li><li><a href="/articles/linux/">Unix/Linux programming</a></li><li><a href="/articles/sourcecode/">Source Code</a></li><li><a href="/articles/standard_library/">Standard Library</a></li><li><a href="/articles/tips/">Tips and Tricks</a></li><li><a href="/articles/tools/">Tools and Libraries</a></li><li><a href="/articles/visualcpp/">Visual C++</a></li><li><a href="/articles/winapi/">Windows API</a></li></ul>
</div>
<div id="I_subnav"></div>
</div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="/">Home page</a> | <a href="/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2016 - All rights reserved - <i>v3.1</i><br><a href="/contact.do?referrer=www.cplusplus.com%2Farticles%2F3wTbqMoL%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
onSession(function(us) {
		document.getElementById('I_subnav').innerHTML=
			us.ok?
				'<div class="sect"><h3><b><a href="/user/">'+us.user+'</a></b></h3><ul>'+
				'<li><a href="/articles/myitems.cgi">My items</a></li>'+
				(us.auth(32768)?'<li><a href="/articles/adminitems.cgi">Admin items</a></li>':'')+
				'</ul></div>'
			:'';
	}); onSession(function (us) {
		var el=document.getElementById('CH_bb'); el.innerHTML='';
		if ( (us.auth(32768)) || ((us.uniqid=='NAMDjE8b')&&(us.auth(128))) ) {
			el.appendChild(btn('Edit article','Edit this version of the article','edit','/articles/edit.cgi?a=3wTbqMoL'));
	
			if (us.auth(32768)) {
				el.appendChild(btn('Delete article','Delete this article','delete','javascript:artdel()'));
			}
	
		}
	});
	function artdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='/articles/delete.cgi?a=3wTbqMoL'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>