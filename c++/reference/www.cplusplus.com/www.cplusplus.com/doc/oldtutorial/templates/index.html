<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Templates - C++ Tutorials</title>
<link rel="canonical" href="http://www.cplusplus.com/doc/oldtutorial/templates/">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" type="text/css" href="/v321/main.css">
<script src="/v321/main.js" type="text/javascript"></script>
<script type='text/javascript'>
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
(function() {
var gads = document.createElement('script');
gads.async = true;
gads.type = 'text/javascript';
var useSSL = 'https:' == document.location.protocol;
gads.src = (useSSL ? 'https:' : 'http:') + 
'//www.googletagservices.com/tag/js/gpt.js';
var node = document.getElementsByTagName('script')[0];
node.parentNode.insertBefore(gads, node);
})();
</script>

<script type='text/javascript'>
googletag.cmd.push(function() {
googletag.defineSlot('/32882001/L', [728, 90], 'div-gpt-ad-1427191279638-0').addService(googletag.pubads());
googletag.enableServices();
});
</script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="/" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="/doc/">Tutorials</a></li>
<li><a href="/doc/oldtutorial/">C++ Language </a></li>
<li class="here">Templates</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div class="C_support">
<div id='div-gpt-ad-1427191279638-0' style='width:728px; height:90px;'>
<script type='text/javascript'>
googletag.cmd.push(function() { googletag.display('div-gpt-ad-1427191279638-0'); });
</script>
</div>
</div>
<div id="I_content">
<div class="C_doc">
<h1>Templates</h1>
<h3>Function templates</h3>
Function templates are special functions that can operate with <i>generic types</i>. This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.<br>
<br>
In C++ this can be achieved using <i>template parameters</i>. A template parameter is a special kind of parameter that can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, template parameters allow to pass also types to a function. These function templates can use these parameters as if they were any other regular type.<br>
<br>
The format for declaring function templates with type parameters is:<br>
<br>
<tt>
template &lt;class identifier&gt; function_declaration;<br>
template &lt;typename identifier&gt; function_declaration;<br>
</tt>
<br>
The only difference between both prototypes is the use of either the keyword <tt>class</tt> or the keyword <tt>typename</tt>. Its use is indistinct, since both expressions have exactly the same meaning and behave exactly the same way.<br>
<br>
For example, to create a template function that returns the greater one of two objects we could use: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> myType&gt;
myType GetMax (myType a, myType b) {
 <var>return</var> (a&gt;b?a:b);
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here we have created a template function with <tt>myType</tt> as its template parameter. This template parameter represents a type that has not yet been specified, but that can be used in the template function as if it were a regular type. As you can see, the function template <tt>GetMax</tt> returns the greater of two parameters of this still-undefined type.<br>
<br>
To use this function template we use the following format for the function call:<br>
<br>
<tt>
function_name &lt;type&gt; (parameters);<br>
</tt>
<br>
For example, to call <tt>GetMax</tt> to compare two integer values of type <tt>int</tt> we can write: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> x,y;
GetMax &lt;<var>int</var>&gt; (x,y);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
When the compiler encounters this call to a template function, it uses the template to automatically generate a function replacing each appearance of <tt>myType</tt> by the type passed as the actual template parameter (<tt>int</tt> in this case) and then calls it. This process is automatically performed by the compiler and is invisible to the programmer.<br>
<br>
Here is the entire example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// function template</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
T GetMax (T a, T b) {
  T result;
  result = (a&gt;b)? a : b;
  <var>return</var> (result);
}

<var>int</var> main () {
  <var>int</var> i=5, j=6, k;
  <var>long</var> l=10, m=5, n;
  k=GetMax&lt;<var>int</var>&gt;(i,j);
  n=GetMax&lt;<var>long</var>&gt;(l,m);
  cout &lt;&lt; k &lt;&lt; endl;
  cout &lt;&lt; n &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, we have used <tt>T</tt> as the template parameter name instead of <tt>myType</tt> because it is shorter and in fact is a very common template parameter name. But you can use any identifier you like.<br>
<br>
In the example above we used the function template <tt>GetMax()</tt> twice. The first time with arguments of type <tt>int</tt> and the second one with arguments of type <tt>long</tt>. The compiler has instantiated and then called each time the appropriate version of the function.<br>
<br>
As you can see, the type <tt>T</tt> is used within the <tt>GetMax()</tt> template function even to declare new objects of that type: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>T result;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Therefore, <tt>result</tt> will be an object of the same type as the parameters <tt>a</tt> and <tt>b</tt> when the function template is instantiated with a specific type.<br>
<br>
In this specific case where the generic type <tt>T</tt> is used as a parameter for <tt>GetMax</tt> the compiler can find out automatically which data type has to instantiate without having to explicitly specify it within angle brackets (like we have done before specifying <tt>&lt;int&gt;</tt> and <tt>&lt;long&gt;</tt>). So we could have written instead:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> i,j;
GetMax (i,j);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Since both <tt>i</tt> and <tt>j</tt> are of type <tt>int</tt>, and the compiler can automatically find out that the template parameter can only be <tt>int</tt>. This implicit method produces exactly the same result:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// function template II</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
T GetMax (T a, T b) {
  <var>return</var> (a&gt;b?a:b);
}

<var>int</var> main () {
  <var>int</var> i=5, j=6, k;
  <var>long</var> l=10, m=5, n;
  k=GetMax(i,j);
  n=GetMax(l,m);
  cout &lt;&lt; k &lt;&lt; endl;
  cout &lt;&lt; n &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how in this case, we called our function template <tt>GetMax()</tt> without explicitly specifying the type between angle-brackets <tt>&lt;&gt;</tt>. The compiler automatically determines what type is needed on each call.<br>
<br>
Because our template function includes only one template parameter (<tt>class T</tt>) and the function template itself accepts two parameters, both of this <tt>T</tt> type, we cannot call our function template with two objects of different types as arguments:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> i;
<var>long</var> l;
k = GetMax (i,l); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would not be correct, since our <tt>GetMax</tt> function template expects two arguments of the same type, and in this call to it we use objects of two different types.<br>
<br>
We can also define function templates that accept more than one type parameter, simply by specifying more template parameters between the angle brackets. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T, <var>class</var> U&gt;
T GetMin (T a, U b) {
  <var>return</var> (a&lt;b?a:b);
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, our function template <tt>GetMin()</tt> accepts two parameters of different types and returns an object of the same type as the first parameter (<tt>T</tt>) that is passed. For example, after that declaration we could call <tt>GetMin()</tt> with:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> i,j;
<var>long</var> l;
i = GetMin&lt;<var>int</var>,<var>long</var>&gt; (j,l);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
or simply:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>i = GetMin (j,l);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
even though <tt>j</tt> and <tt>l</tt> have different types, since the compiler can determine the appropriate instantiation anyway.<br>
<br>
<h3>Class templates</h3>
We also have the possibility to write class templates, so that a class can have members that use template parameters as types. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mypair {
    T values [2];
  <var>public</var>:
    mypair (T first, T second)
    {
      values[0]=first; values[1]=second;
    }
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The class that we have just defined serves to store two elements of any valid type. For example, if we wanted to declare an object of this class to store two integer values of type <tt>int</tt> with the values 115 and 36 we would write:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mypair&lt;<var>int</var>&gt; myobject (115, 36); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
this same class would also be used to create an object to store any other type:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mypair&lt;<var>double</var>&gt; myfloats (3.0, 2.18); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The only member function in the previous class template has been defined inline within the class declaration itself. In case that we define a function member outside the declaration of the class template, we must always precede that definition with the <tt>template &lt;...&gt;</tt> prefix:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br></code></pre></td>
<td class="source"><pre><code><cite>// class templates</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mypair {
    T a, b;
  <var>public</var>:
    mypair (T first, T second)
      {a=first; b=second;}
    T getmax ();
};

<var>template</var> &lt;<var>class</var> T&gt;
T mypair&lt;T&gt;::getmax ()
{
  T retval;
  retval = a&gt;b? a : b;
  <var>return</var> retval;
}

<var>int</var> main () {
  mypair &lt;<var>int</var>&gt; myobject (100, 75);
  cout &lt;&lt; myobject.getmax();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>100</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice the syntax of the definition of member function getmax:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt;
T mypair&lt;T&gt;::getmax () </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Confused by so many <tt>T</tt>'s? There are three <tt>T</tt>'s in this declaration: The first one is the template parameter. The second <tt>T</tt> refers to the type returned by the function. And the third <tt>T</tt> (the one between angle brackets) is also a requirement: It specifies that this function's template parameter is also the class template parameter.<br>
<br>
<h3>Template specialization</h3>
If we want to define a different implementation for a template when a specific type is passed as template parameter, we can declare a specialization of that template.<br>
<br>
For example, let's suppose that we have a very simple class called <tt>mycontainer</tt> that can store one element of any type and that it has just one member function called <tt>increase</tt>, which increases its value. But we find that when it stores an element of type <tt>char</tt> it would be more convenient to have a completely different implementation with a function member <tt>uppercase</tt>, so we decide to declare a class template specialization for that type:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br></code></pre></td>
<td class="source"><pre><code><cite>// template specialization</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<cite>// class template:</cite>
<var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mycontainer {
    T element;
  <var>public</var>:
    mycontainer (T arg) {element=arg;}
    T increase () {<var>return</var> ++element;}
};

<cite>// class template specialization:</cite>
<var>template</var> &lt;&gt;
<var>class</var> mycontainer &lt;<var>char</var>&gt; {
    <var>char</var> element;
  <var>public</var>:
    mycontainer (<var>char</var> arg) {element=arg;}
    <var>char</var> uppercase ()
    {
      <var>if</var> ((element&gt;=<kbd>'a'</kbd>)&amp;&amp;(element&lt;=<kbd>'z'</kbd>))
      element+=<kbd>'A'</kbd>-<kbd>'a'</kbd>;
      <var>return</var> element;
    }
};

<var>int</var> main () {
  mycontainer&lt;<var>int</var>&gt; myint (7);
  mycontainer&lt;<var>char</var>&gt; mychar (<kbd>'j'</kbd>);
  cout &lt;&lt; myint.increase() &lt;&lt; endl;
  cout &lt;&lt; mychar.uppercase() &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>8
J</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is the syntax used in the class template specialization:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;&gt; <var>class</var> mycontainer &lt;<var>char</var>&gt; { ... };</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
First of all, notice that we precede the class template name with an empty <tt>template&lt;&gt;</tt> parameter list. This is to explicitly declare it as a template specialization.<br>
<br>
But more important than this prefix, is the <tt>&lt;char&gt;</tt> specialization parameter after the class template name. This specialization parameter itself identifies the type for which we are going to declare a template class specialization (<tt>char</tt>). Notice the differences between the generic class template and the specialization:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt; <var>class</var> mycontainer { ... };
<var>template</var> &lt;&gt; <var>class</var> mycontainer &lt;<var>char</var>&gt; { ... };</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first line is the generic template, and the second one is the specialization.<br>
<br>
When we declare specializations for a template class, we must also define all its members, even those exactly equal to the generic template class, because there is no "inheritance" of members from the generic template to the specialization.<br>
<br>
<h3>Non-type parameters for templates</h3>
Besides the template arguments that are preceded by the <tt>class</tt> or <tt>typename</tt> keywords , which represent types, templates can also have regular typed parameters, similar to those found in functions. As an example, have a look at this class template that is used to contain sequences of elements:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br></code></pre></td>
<td class="source"><pre><code><cite>// sequence template</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
<var>class</var> mysequence {
    T memblock [N];
  <var>public</var>:
    <var>void</var> setmember (<var>int</var> x, T value);
    T getmember (<var>int</var> x);
};

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
<var>void</var> mysequence&lt;T,N&gt;::setmember (<var>int</var> x, T value) {
  memblock[x]=value;
}

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
T mysequence&lt;T,N&gt;::getmember (<var>int</var> x) {
  <var>return</var> memblock[x];
}

<var>int</var> main () {
  mysequence &lt;<var>int</var>,5&gt; myints;
  mysequence &lt;<var>double</var>,5&gt; myfloats;
  myints.setmember (0,100);
  myfloats.setmember (3,3.1416);
  cout &lt;&lt; myints.getmember(0) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; myfloats.getmember(3) &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>100
3.1416 </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It is also possible to set default values or types for class template parameters. For example, if the previous class template definition had been:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T=<var>char</var>, <var>int</var> N=10&gt; <var>class</var> mysequence {..};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
We could create objects using the default template parameters by declaring:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mysequence&lt;&gt; myseq;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Which would be equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mysequence&lt;<var>char</var>,10&gt; myseq;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<h3>Templates and multiple-file projects</h3>
From the point of view of the compiler, templates are not normal functions or classes. They are compiled on demand, meaning that the code of a template function is not compiled until an instantiation with specific template arguments is required. At that moment, when an instantiation is required, the compiler generates a function specifically for those arguments from the template.<br>
<br>
When projects grow it is usual to split the code of a program in different source code files. In these cases, the interface and implementation are generally separated. Taking a library of functions as example, the interface generally consists of declarations of the prototypes of all the functions that can be called. These are generally declared in a "header file" with a .h extension, and the implementation (the definition of these functions) is in an independent file with c++ code.<br>
<br>
Because templates are compiled when required, this forces a restriction for multi-file projects: the implementation (definition) of a template class or function must be in the same file as its declaration. That means that we cannot separate the interface in a separate header file, and that we must include both interface and implementation in any file that uses the templates.<br>
<br>
Since no code is generated until a template is instantiated when required, compilers are prepared to allow the inclusion more than once of the same template file with both declarations and definitions in a project without generating linkage errors.<br>
<table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/oldtutorial/polymorphism/" rel="prev"><img src="/ico/32arrowleft.png" width="32" height="32" alt="Previous">Previous:<br><b>Polymorphism</b></a></td><td class="index"><a href="/doc/oldtutorial/" rel="index"><img src="/ico/32doc.png" width="32" height="32" alt="Index"><br>Index</a></td><td class="next"><a href="/doc/oldtutorial/namespaces/" rel="next"><img src="/ico/32arrowright.png" width="32" height="32" alt="Next">Next:<br><b>Namespaces</b></a></td></tr></table></div><div id="CH_bb"></div></div>
<script type="text/javascript">
    google_ad_client = "ca-pub-1444228343479937";
    google_ad_slot = "9701143201";
    google_ad_width = 728;
    google_ad_height = 90;
</script>
<!-- leaderboard -->
<script type="text/javascript"
src="//pagead2.googlesyndication.com/pagead/show_ads.js">
</script></div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="/">C++</a></b></h3>
<ul>
<li class="folder info"><a href="/info/">Information</a></li>
<li class="folder selected doc"><a href="/doc/">Tutorials</a></li>
<li class="folder reference"><a href="/reference/">Reference</a></li>
<li class="folder articles"><a href="/articles/">Articles</a></li>
<li class="folder forum"><a href="/forum/">Forum</a></li>
</ul>
</div>
<div class="C_BoxLabels C_BoxSort sect" id="doc_box">
<h3><b><a href="/doc/">Tutorials</a></b></h3>
<ul>
<li class="cpp98 cpp11 folder"><a href="/doc/tutorial/"><span>C++ Language</span></a></li>
<li><a href="/doc/ascii/"><span>Ascii Codes</span></a></li>
<li><a href="/doc/boolean/"><span>Boolean Operations</span></a></li>
<li><a href="/doc/hex/"><span>Numerical Bases</span></a></li>
</ul>
</div>
<div class="C_BoxLabels C_BoxSort sect" id="oldtutorial_box">
<h3><b><a href="/doc/oldtutorial/">C++ Language (C++98)</a></b></h3>
<ul>
<li class="C_Collapsable"><h4>Introduction:</h4><ul>
<li><a href="/doc/oldtutorial/introduction/"><span>Instructions for use</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Basics of C++:</h4><ul>
<li><a href="/doc/oldtutorial/program_structure/"><span>Structure of a program</span></a></li>
<li><a href="/doc/oldtutorial/variables/"><span>Variables. Data Types.</span></a></li>
<li><a href="/doc/oldtutorial/constants/"><span>Constants</span></a></li>
<li><a href="/doc/oldtutorial/operators/"><span>Operators</span></a></li>
<li><a href="/doc/oldtutorial/basic_io/"><span>Basic Input/Output</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Control Structures:</h4><ul>
<li><a href="/doc/oldtutorial/control/"><span>Simple control structures</span></a></li>
<li><a href="/doc/oldtutorial/functions/"><span>Functions (I)</span></a></li>
<li><a href="/doc/oldtutorial/functions2/"><span>Functions (II)</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Compound Data Types:</h4><ul>
<li><a href="/doc/oldtutorial/arrays/"><span>Arrays</span></a></li>
<li><a href="/doc/oldtutorial/ntcs/"><span>Character Sequences</span></a></li>
<li><a href="/doc/oldtutorial/pointers/"><span>Pointers</span></a></li>
<li><a href="/doc/oldtutorial/dynamic/"><span>Dynamic Memory</span></a></li>
<li><a href="/doc/oldtutorial/structures/"><span>Data Structures</span></a></li>
<li><a href="/doc/oldtutorial/other_data_types/"><span>Other Data Types</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Object Oriented Programming:</h4><ul>
<li><a href="/doc/oldtutorial/classes/"><span>Classes (I)</span></a></li>
<li><a href="/doc/oldtutorial/classes2/"><span>Classes (II)</span></a></li>
<li><a href="/doc/oldtutorial/inheritance/"><span>Friendship and inheritance</span></a></li>
<li><a href="/doc/oldtutorial/polymorphism/"><span>Polymorphism</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>Advanced Concepts:</h4><ul>
<li class="selected"><a href="/doc/oldtutorial/templates/"><span>Templates</span></a></li>
<li><a href="/doc/oldtutorial/namespaces/"><span>Namespaces</span></a></li>
<li><a href="/doc/oldtutorial/exceptions/"><span>Exceptions</span></a></li>
<li><a href="/doc/oldtutorial/typecasting/"><span>Type Casting</span></a></li>
<li><a href="/doc/oldtutorial/preprocessor/"><span>Preprocessor directives</span></a></li>
</ul></li>
<li class="C_Collapsable"><h4>C++ Standard Library:</h4><ul>
<li><a href="/doc/oldtutorial/files/"><span>Input/Output with files</span></a></li>
</ul></li>
</ul>
</div>
<div id="I_subnav"></div>
<div class="C_ad234">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-7688470879129516";
google_ad_slot = "7445514729";
google_ad_width = 234;
google_ad_height = 60;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div></div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="/">Home page</a> | <a href="/privacy.do">Privacy policy</a><br>&copy; cplusplus.com, 2000-2016 - All rights reserved - <i>v3.1</i><br><a href="/contact.do?referrer=www.cplusplus.com%2Fdoc%2Foldtutorial%2Ftemplates%2F">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
 onSession ( function(us) {
		el=document.getElementById('CH_bb'); el.innerHTML='';
		if (us.auth(4096)) {
			
			el.appendChild(btn('Edit Page','Edit Page','edit','/doc/edit.cgi?a=oldtutorial+templates'));
			el.appendChild(btn('Delete Page','Delete Page','delete','javascript:docdel()'));
		}
	});
	function docdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='/doc/delete.cgi?a=oldtutorial+templates'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>